module formal_top;

  // 1. Inputs (Generated by Formal Tool automatically)
  logic clk;
  logic rst_n;

  // 2. Instantiate Interfaces
  // The tool will drive these signals automatically
  port_if port0(clk, rst_n);
  port_if port1(clk, rst_n);
  port_if port2(clk, rst_n);
  port_if port3(clk, rst_n);

  // 3. Instantiate DUT (Device Under Test)
  switch_4port dut (
    .clk(clk),
    .rst_n(rst_n),
    .port0(port0),
    .port1(port1),
    .port2(port2),
    .port3(port3)
  );

  // 4. BIND ASSERTIONS (Directly here - No separate file needed)
  // Note: We access the sub-modules via 'dut.' path
  
  // Bind FIFO (Note: module name is 'fifo' lowercase in your file)
  bind fifo fifo_sva #(
      .DEPTH(packet_pkg::DEPTH), 
      .PACKET_WIDTH(packet_pkg::PACKET_WIDTH)
  ) i_fifo_props (
      .clk(clk),
      .rst_n(rst_n),
      .rd_en(rd_en),
      .fifo_empty(fifo_empty),
      .fifo_count(fifo_count),
      .header_out(header_out),
      .rd_ptr(rd_ptr),
      .mem(mem)
  );

  // Bind Switch Port
  // We use hierarchical path 'port_fifo.header_out' to fix the missing signal issue
  bind switch_port port_sva i_port_props (
      .clk(clk),
      .rst_n(rst_n),
      .fifo_empty(fifo_empty),
      .current_state(current_state),
      .grant(grant),
      .pkt_valid(pkt_valid),
      .pkt_type(pkt_type),
      .read_en_fifo(read_en_fifo),
      .source_in(port_fifo.header_out[3:0]), 
      .target_in(port_fifo.header_out[7:4])
  );

  // Bind Arbiter
  bind arbiter arbiter_sva i_arb_props (.*);

endmodule